import Cocoa
import QuickLook


class DraggableView: NSView {
    override func mouseDown(with event: NSEvent) {
        // Pass the mouseDown event to the super class
//        super.mouseDown(with: event)

        // Forward the event to the window for dragging
        if let window = self.window {
            window.performDrag(with: event)
        }
    }
    
    override func resetCursorRects() {
        self.discardCursorRects()
        super.addCursorRect(bounds, cursor: .arrow)
    }
    
    var trackingArea: NSTrackingArea?
    func setupTracking() {
        if self.trackingArea == nil {
            self.trackingArea = NSTrackingArea(rect: self.bounds, options: [.mouseEnteredAndExited, .activeAlways, .activeWhenFirstResponder, .activeWhenFirstResponder, .enabledDuringMouseDrag, .mouseEnteredAndExited, .mouseMoved, .cursorUpdate], owner: self, userInfo: nil)
            self.addTrackingArea(self.trackingArea!)
        }
    }
    
    override func updateTrackingAreas() {
        self.trackingArea = NSTrackingArea(rect: self.bounds, options: [.mouseEnteredAndExited, .activeAlways, .activeWhenFirstResponder, .activeWhenFirstResponder, .enabledDuringMouseDrag, .mouseEnteredAndExited, .mouseMoved, .cursorUpdate], owner: self, userInfo: nil)
        self.addTrackingArea(self.trackingArea!)
    }
    
    override func mouseMoved(with theEvent: NSEvent) {
        NSCursor.arrow.set()
    }
}

class WindowDragView: NSView {
    // override var acceptsFirstResponder: Bool {
    //     return true
    // }
    
    // override func becomeFirstResponder() -> Bool {
    //     return true
    // }
    
    // override func resignFirstResponder() -> Bool {
    //     return true
    // }
    override public func mouseDown(with event: NSEvent) {
        // Pass the mouseDown event to the super class
        // super.mouseDown(with: event)
        window?.performDrag(with: event)
    }
    override func hitTest(_ point: NSPoint) -> NSView? {
        let hitView = super.hitTest(point)
        return (hitView == self) ? nil : hitView
    }
}

protocol DragViewDelegate {
    func mouseenter()
    func mouseout()
}

class MyDragView: WindowDragView {
    static let allowedTypes: [NSPasteboard.PasteboardType] = [.tiff, .color, .string, .fileURL]
    
    private let pasteboardTypeDenylist: Set = [
        "org.nspasteboard.TransientType",
        "org.nspasteboard.ConcealedType",
        "org.nspasteboard.AutoGeneratedType",
        "com.agilebits.onepassword",
        "com.typeit4me.clipping",
        "de.petermaurer.TransientPasteboardType",
        "Pasteboard generator type",
        "net.antelle.keeweb",
    ]
    
    private let pasteboardTypeSupportList: Set<NSPasteboard.PasteboardType> = [
        .fileURL,
        .string,
        .rtf,
        .tiff, .png,
        .html,
        .rtfd, .tabularText, .color, .URL
    ]
    
    var delegate: DragViewDelegate?
    
    var onDroppped: ([NSPasteboard.PasteboardType: Data]) -> Void = { _ in }
       
       override init(frame frameRect: NSRect) {
           super.init(frame: frameRect)
           commonInit()
       }
       
       required init?(coder: NSCoder) {
           super.init(coder: coder)
           commonInit()
       }
       
       private func commonInit() {
           // Register for multiple dragged types in the view
           registerForDraggedTypes(Self.allowedTypes)
       }
    
    override func prepareForDragOperation(_ sender: NSDraggingInfo) -> Bool {
        print("prepareForDragOperation")
        return true
    }
       
    override func draggingEntered(_ sender: NSDraggingInfo) -> NSDragOperation {
        let canReadPasteboardObjects = sender.draggingPasteboard.canReadObject(forClasses: [NSImage.self, NSColor.self, NSString.self, NSURL.self],
                                                                               options: acceptableUTITypes())
        
        if canReadPasteboardObjects {
            highlight()
            delegate?.mouseenter()
            return .copy
        }

        return NSDragOperation()
    }
    
    
    override func performDragOperation(_ sender: NSDraggingInfo) -> Bool {
        
        let pasteboard = NSPasteboard(name: .drag)

        if let fileURLs = pasteboard.readObjects(forClasses: [NSURL.self], options: nil) as? [URL], !fileURLs.isEmpty {
            // You can now access information about the dragged file URLs
            for fileURL in fileURLs {
//                saveFileToDataDirectory(from: fileURL)
            }

            // Perform actions to show drop indicator based on the dragged items
            // Update UI or show drop indicator as needed
//            NotificationCenter.default.post(name: .dragEnteredNotification, object: nil)
        }
        
        guard let pasteboardObjects = sender.draggingPasteboard.readObjects(forClasses: [NSImage.self, NSColor.self, NSString.self, NSURL.self], options: acceptableUTITypes()), pasteboardObjects.count > 0 else {
            return false
        }
        
        print("performDragOperation")
        
        var data = [NSPasteboard.PasteboardType: Data]()
        
        var isImage = false
        pasteboardObjects.forEach { (object) in
            if let image = object as? NSImage {
                isImage = true
                print("Image \(image)")
                data[.tiff] = image.tiffRepresentation
            }

            if let color = object as? NSColor {
                print("color \(color)")
                data[.color] = color.toHex()?.data(using: .utf8)
            }

            if let quote = object as? NSString {
                print("sting \(quote)")
                data[.string] = String(quote).data(using: .utf8)
            }

            if let url = object as? NSURL {
                print("fileUrl \(url as URL)")
                let currentUrl = url as URL
                data[.fileURL] = currentUrl.absoluteString.data(using: .utf8)
            }
        }
        
        sender.draggingDestinationWindow?.orderFrontRegardless()
        
        onDroppped(data)
        return true
    }

    func generatePreviewImage(for url: URL) -> NSImage? {
        print("url \(url)")
        let previewSize = CGSize(width: 100, height: 100) // Set the desired size for the preview image
        
        if let previewRef = QLThumbnailImageCreate(kCFAllocatorDefault, url as CFURL, previewSize, [:] as CFDictionary) {
            let cgImage = previewRef.takeRetainedValue() as CGImage
            return NSImage(cgImage: cgImage, size: previewSize)
        }
        
        return nil
    }
    
    override func draggingEnded(_ sender: NSDraggingInfo) {
        unhighlight()
    }


    override func draggingExited(_ sender: NSDraggingInfo?) {
        unhighlight()
        delegate?.mouseout()
    }
    
    
    func acceptableUTITypes() -> [NSPasteboard.ReadingOptionKey : Any] {
        return [NSPasteboard.ReadingOptionKey.urlReadingFileURLsOnly: NSNumber(value: false)]
    }
    
    func handleFileURLObject(_ url: URL) {
        var isDirectory: ObjCBool = false
            if FileManager.default.fileExists(atPath: url.path, isDirectory: &isDirectory) {
                if url.pathExtension == "app" {
                   // Handle .app files
                   handleAppBundleURL(url)
               } else if isDirectory.boolValue {
                    // Handle directories
                    print(url)
                } else if let image = NSImage(contentsOfFile: url.path) {
                    // Handle image files
//                    avatarInfo.setImageData(using: image)
                    print(url.path)
                } else {
                    do {
                        let text = try String(contentsOf: url, encoding: .utf8)
//                        avatarInfo.quote = text
                        print(text)
                    } catch {
                        // Handle errors
                        print("Error handling file: \(error)")
                    }
                }
            }
    }
    
    func handleAppBundleURL(_ url: URL) {
        // Verify that the URL points to a valid .app bundle
        if let appBundle = Bundle(url: url) {
            // Get the app name
            if let appName = appBundle.object(forInfoDictionaryKey: "CFBundleName") as? String {
                print("App Name: \(appName)")
                // You can display the app name as needed.
            }
            
            // Get the app icon
            if let appIconFile = appBundle.object(forInfoDictionaryKey: "CFBundleIconFile") as? String,
               let appIconPath = appBundle.path(forResource: appIconFile, ofType: "icns") {
                let appIcon = NSImage(contentsOfFile: appIconPath)
//                avatarInfo.setImageData(using: appIcon!)
                // You can display the app icon in an NSImageView or another appropriate UI element.
                // For example, you can set it as the image of an NSImageView:
                // imageView.image = appIcon
            }
        }
    }
    
    
    func highlight() {
        self.layer?.borderColor = NSColor.controlAccentColor.cgColor
        self.layer?.borderWidth = 2.0
    }
    
    
    func unhighlight() {
        self.layer?.borderColor = NSColor.clear.cgColor
        self.layer?.borderWidth = 0.0
    }
    
    override func draw(_ dirtyRect: NSRect) {
        NSColor.clear.set()
//        if let shelfVC = self.window?.contentViewController as? HudViewController {
//            print(shelfVC.shelf)
//            shelfVC.shelf.data.backgroundColor.set()
//        }
//        NSColor(calibratedRed: 235/255, green: 38/255, blue: 1/255, alpha: 0.5).set()
        dirtyRect.fill()
    }
}

